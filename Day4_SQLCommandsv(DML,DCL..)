Databases without data are useless, Data without queries is powerless -> SQL gives power through queries 

 Component                Role                         
 MySQL Server    | Stores & processes data      
 MySQL Workbench | Tool to interact with server 
-> If noo Workbench -> You can’t talk to MySQL stored Data amigo's

Realtime Example: Online Shopping App
Business/Industty Concepts:
Customers
Products
Orders
Payments

SQL Concepts:
Tables
Columns
Rows
Relationships
-> Remember this mapping is the soul of SQL

As a Professional will follow this SPARK:
SELECT database
-> Check table structure
-> Insert clean data
-> Query with purpose
Don't do random querying have the purpose when writing the query

Create a new Connection/Server-> DB/Schema ->table:
Algonex -> Connection/Server
SPARK -> DB   create database SPARK;
products - > Table
Columns:
product_id
product_name
category
price
stock

Tasks:
- insert 5 products
- Write 5 SELECT queries using WHERE

Business Question
        |
Identify Table
        |
Select Required Columns
        |
Apply WHERE Conditions
        |
Validate Result

SQL Commands? Observe : SQL commands are instructions you give to the database engine to manage,
store, control, and analyze data
Ex: These instrcutions/Commands having a special meaning inside SQL Workbench to make the communication with DB's 
like Spanish people don't understand Telugu and vice versa 
Not all commands do the same job (Show fig. there about commands & dtypes)

Just like in Algonex company:
- Some people build infrastructure
- Some work with data
- Some control/monitoring access
- Some manage transactions
SQL commands are also divided this way

SQL commands are divided into 5 categories:
DDL  -> Structure
DML  -> Data Change
DQL  -> Questions/Data Fetch
DCL  -> Security/Permissions
TCL  -> Transactions
If a fresher understands this flow clearly -> they are already above average

1. DDL — Data Definition Language ->(Database Architecture/Structure Layer)
DDL commands define the structure of the database like Building the Algonex office, not working yet inside it
-> Just like Constructed building without any furniture inside

DDL Commands:
CREATE
ALTER
DROP
TRUNCATE
RENAME

1. CREATE - Creating Business/Data Real entity
SPARK Examples:
- Create a database for a company
- Create a table for employees and orders
- Creating new modules (Users, Orders, Payments)
- Spinning up new services (microservices DB)
- Setting up staging / prod schemas

CREATE DATABASE database_name;
 [Ex: CREATE DATABASE company_db; ]
USE company_db;

-- Creating table inside current  DB
CREATE TABLE table_name (
    column1 datatype [constraints],
    column2 datatype,
    ...
);

Ex: CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    name VARCHAR(100),
    Salary Decimal(60,30)
);    
Ex:2 
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    full_name VARCHAR(100) NOT NULL,
    email VARCHAR(150) UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
Note: Always design with:
- Primary keys
- Indexes
- Constraints
Otherwise performance + data quality breaks in main production kadaa

DDL commands change metadata/Main data (means it will do changes on permanent/main data), not just data

SQL COMMENTS
-> 1.Single line comments (-- write desc)
-> Multiline Comments (/* comments in two/more lines */)
SQL Datatypes

2. ALTER - Business Change Management/Schema Evolution Without Breaking Production
modifying an existing main business(Tables,Colums) structure

Real-world examples:
- Company adds a new column -> email, Contact
- Company changes salary format
- Company renames a column (Employee_ID -> emp_id)
- New feature requires a new column
- Renaming columns
- Changing datatype after feedback

Examples:
ALTER TABLE employees
ADD email VARCHAR(100);

ALTER TABLE users ADD phone VARCHAR(15);

Alter Various forms: 
ALTER TABLE table_name ADD column_name datatype;
ALTER TABLE table_name MODIFY column_name datatype;
ALTER TABLE table_name DROP column_name;
ALTER TABLE table_name RENAME TO new_table_name;

3. DROP - Permanent Destruction
This command Completely removes the structure + data from the Database
But it can be ROLLBACK, if it is stored in SAVEPOINT

DROP TABLE employees;
DROP DATABASE Database_name;

Senior-level warning(It not followed you'll get fired):
- DROP has NO undo(But Rollback Only in-case of stored data in Savepoint) 
- Rarely used in production/final modifications
- Mostly used in development/testing

4. TRUNCATE - Resetting Data (Fast & Dangerous)
It deletes all rows, keeps structure(Tables with Colums inside Database)

TRUNCATE TABLE employees;

Difference from DELETE: (SPARK Ask yourself) 
- Faster
- Cannot rollback
- No WHERE condition

Used when:
- Resetting test/Sample data
- Cleaning staging environments
- Reset mobile loosing all contacts but keeping the s/w apps

2. DML - Data Manipulation Language (Business/data Modifications Activity Layer)-> Ikkadee manupulations anni hapen avuthaay
DML commands work with actual business data to make modifications to the tables
Examples: Employees joining, orders happening, payments processing or any sort of modications/Processes 

DML Commands: You're only having access to insert, update, delete your data while ordering from Amazon with address, contact, pincode, etc.,
INSERT
UPDATE
DELETE

1.INSERT -> New business Events(Modification/new records) coming into DB
Examples:
- New user signup into Algonex
- New order placed from Flipkart
- New employee joined

type1(Without mention Columns): INSERT INTO table_name VALUES (value1, value2, ...);
Note: Don't use Type1 because column order changes will break your app

Type2: INSERT INTO table_name (column1, column2)
VALUES (value1, value2);

INSERT INTO employees (employee_id, name, department)
VALUES (1039871, 'Harshitha', 'IT');

INSERT INTO users (full_name, email)
VALUES ('Sainath Namala', 'sainath@gmail.com');

-> This INSERT represents real-time events(Amazon data insert when ordering)- not just data entry

2. UPDATE- Business Data Corrections
It is for fixing or changing business/company data
Examples chudandi:
- Salary hike (10k -> 90% hikes gives 19k)
- Department change (Developer -> Testing)
- Profile update (Changes in Photo, details,..)

UPDATE table_name
SET column1 = value1
WHERE condition; -- Which updates Column value/values on following condition 

UPDATE table_name
SET column1 = value1; -- This updates the entire column with value1

Ex: UPDATE employees
SET department = 'Finance'
WHERE employee_id = 101;

3. DELETE - Business/company data Removal with certain condition 
-> Removing business records logically based on the condition

DELETE FROM table_name
WHERE condition;

Ex: DELETE FROM Spark
WHERE spark_id = 101;

How difference from TRUNCATE:
- DELETE is row-level
- DELETE can use WHERE
- DELETE can be rolled back (with transactions)

3. DQL - Data Query Language (IDi decision-Making/output retrieval Layer)
DQL is where SQL becomes valuable like asking questions to data and getting meaningful insights
Only one command SELECT-> but don’t underestimate it will get the output data using SELECT only

Examples:
- Who are our top employees?
- What are today’s sales?
- Which product is failing?

SELECT * FROM table_name; -- * represents all columns
SELECT column1, column2 FROM table_name;

ex: SELECT name, department
FROM employees;

SELECT columns
FROM table
WHERE condition
ORDER BY column
LIMIT n OFFSET m;

SELECT user_id, full_name, email
FROM users
ORDER BY user_id DESC
LIMIT 10;

Note: Algonex never use SELECT * in production APIs
-> It breaks performance + contracts (Soo mention column names instead)

-> We’ll go extremely deep into SELECT later on(filters, joins, analytics)

DROP DATABASE database_name;
DROP TABLE table_name;
TRUNCATE TABLE table_name;
ALTER TABLE table_name ADD column_name datatype;
ALTER TABLE table_name MODIFY column_name datatype;
ALTER TABLE table_name DROP column_name;
ALTER TABLE table_name RENAME TO new_table_name;


5. TCL (Transaction Control Language)- Safety system for data
How companies/ATM's ensure money, inventory, bookings never go wrong
-> It ensures that multiple related changes happen together or don’t happen at all
-> Either the full business operation succeeds, or everything is undone

TCL is used whenever:
- Money is transferred
- Orders are placed
- Seats are booked
- Inventory is updated
- Wallet balances change
-> If one step fails and others succeed -> data becomes wrong, TCL prevents this

TCL ensures ACID properties:
- Atomicity
- consistency
- Isolation
- durability

CREATE DATABASE bank_db;
USE bank_db;

CREATE TABLE accounts (
    acc_id INT PRIMARY KEY,
    name VARCHAR(50),
    balance INT
);

INSERT INTO accounts VALUES
(1, 'Dithya', 5000),
(2, 'Subhash', 3000); -- Now imagine this as a bank/wallet system

COMMIT, ROLLBACK, SAVEPOINT

1. START TRANSACTION -  Begin Safe Operations
-> Now I’m starting a business process that has multiple steps, treat them as one unit

start TRANSACTION;

Used when: 
-> Multiple queries must succeed together
-> Payment + order + inventory update
(Ex: When you start payment Transaction it should complete the order commit 
completely/come to initial step and update payment details)

2. COMMIT -> Make Changes Permanent if everything is ok

COMMIT;

Where it is used:
- Payment succeeded
- Order placed
- Booking confirmed
START TRANSACTION;

UPDATE accounts SET balance = balance - 1000 WHERE acc_id = 1;  -- Arjun pays
UPDATE accounts SET balance = balance + 1000 WHERE acc_id = 2;  -- Neha receives

COMMIT;
->Both updates succeed
-> Money moves correctly
-> Changes become permanent

3. ROLLBACK — Something went wrong, Undo Everything (Safety Purpose -> Example chudham)
ROLLBACK;

When:
- payment failed
- Inventory insufficient
- any step errors/failed

Example Without TCL (Wrong Way chudandii)
UPDATE accounts SET balance = balance - 1000 WHERE acc_id = 1;
-- Server crashes here kadaa
UPDATE accounts SET balance = balance + 1000 WHERE acc_id = 2;
-- Money is deducted but not added, data is corrupted

Example With TCL (Correct Way ippudu chudu)
START TRANSACTION;
UPDATE accounts SET balance = balance - 1000 WHERE acc_id = 1;
-- Something goes wrong
ROLLBACK;
-- Since second step didn’t complete
-- ROLLBACK undoes the first step
-- Data stays safe

4. SAVEPOINT — Partial Rollback-> Undo only part of the work (Advanced use antaam)
Used in:
- Booking systems
- Multi-step workflows
- Complex order flows
Example flow chudandi:
1. Create order
2. Deduct wallet
3-Reserve inventory
If step 3 fails -> undo step 2 only

SAVEPOINT sp_name;
ROLLBACK TO sp_name;

Booking Flow CHudhaama:
START TRANSACTION;

INSERT INTO bookings (...) VALUES (...);

SAVEPOINT after_booking;

UPDATE inventory SET seats = seats - 1 WHERE flight_id = 10;

-- If inventory update fails
ROLLBACK TO after_booking;

COMMIT;

Savepoints inkoo example flow chudu:
START TRANSACTION;
UPDATE accounts SET balance = balance - 500 WHERE acc_id = 1;  -- deduct wallet
SAVEPOINT after_wallet;

-- Try another step (simulate failure)
UPDATE accounts SET balance = balance + 500 WHERE acc_id = 999;  -- invalid account
ROLLBACK TO after_wallet;
COMMIT;

-> Deduction happened
-> Second update failed
-> Roll back only to savepoint
-> Commit remaining safe steps

5. AUTOCOMMIT - Dinni hidden transaction Behavior antaam
By default: Every query is auto-committed (saved immediately)
Check: SELECT @@autocommit;
In batch jobs / ETL: SET autocommit = 0; -- Now you control manually when data is saved using COMMIT/ROLLBACK

AUTOCOMMIT = ON (Idi defaultga untundhi)

 Real Systemloo                    TCL Usage                            
 UPI / Banking     | Money transfer must be atomic        
 E-commerce        | Order + inventory + payment together 
Ticket Booking | Seat lock + payment + confirmation   
 ERP           | Multi-table updates                  
 Wallet Apps   | Debit + credit                       

ILAA CHESKOO EPPUDINAA TCL Commands vadthunnappudu:
START TRANSACTION;
-- operations
COMMIT;  -- or ROLLBACK

Saree GPay payment System Working chudhama:
START TRANSACTION;

UPDATE wallets SET balance = balance - 1000 WHERE user_id = 1;
UPDATE wallets SET balance = balance + 1000 WHERE user_id = 2;

INSERT INTO transactions(user_id, amount, status)
VALUES (1, 1000, 'SUCCESS');

COMMIT;

Ippudu edina system fail ayindi antee:
then: ROLLBACK;
-> Ilaane banks, UPI, wallets, e-commerce stay correct anamaata

Using TCL Commands in MySQL Workbench (Hands-on, Comapnylo follow ayye  Way)
Open MySQL Workbench -> connect as root, then run:
CREATE DATABASE finance_db;
USE finance_db;

CREATE TABLE wallets (
    user_id INT PRIMARY KEY,
    name VARCHAR(50),
    balance INT
);

INSERT INTO wallets VALUES
(1, 'JayaKrishna', 5000),
(2, 'DIthya', 3000)
(3, 'Niharika', 30000); -- wallet/paymnt system used in fintech & e-commerceloo

1st Step: START TRANSACTION — Begin a Safe Business Operation (Endukoo chudandi)
Used when:
- Transferring money
- Placing orders
- Booking tickets
- Updating inventory + order status together

START TRANSACTION; 

2nd Step:
UPDATE wallets
SET balance = balance - 1000
WHERE user_id = 1;

UPDATE wallets
SET balance = balance + 1000
WHERE user_id = 2;

Money is moved from JayaKrishna to DIthya
At this point:
- Data is not permanent yet
- It’s still inside the transaction

3rd step: COMMIT — Make It Permanent (Success Case idi)
COMMIT; -- Payment succeeded -> save changes permanently
SELECT * FROM wallets; -- You're zeeing updated balances right

4th Step: ROLLBACK — Undo Everything (Failure Case)
Start a new transaction:
START TRANSACTION;
-- Okasaari ivi kuda try cheyandi
UPDATE wallets SET balance = balance - 10000 WHERE user_id = 1;  -- Not enough money
UPDATE wallets SET balance = balance + 10000 WHERE user_id = 2;

-- Now instead of COMMIT:
ROLLBACK;

SELECT * FROM wallets; -- Chusthee balances will be unchanged
This is how banks & UPI apps prevent wrong transfers

5sth Step: SAVEPOINT — Partial Rollback
In a booking system:
- Create booking
= Deduct wallet
- Reserve inventory
If step 3 fails -> undo step 2 only

-- IDi overallga
START TRANSACTION;

UPDATE wallets SET balance = balance - 500 WHERE user_id = 1;

SAVEPOINT after_wallet_deduct;

-- Simulate failure or wrong update
UPDATE wallets SET balance = balance + 500 WHERE user_id = 999;  -- invalid user

ROLLBACK TO after_wallet_deduct;

COMMIT;
-- Wallet deduction is undone, but transaction is still valid

6th Step: (ANdaru students aduguthuntaaru )
AUTOCOMMIT — Hidden Behavior (Important for Fresher amigos)
Every query commits automatically default in MySQL
SELECT @@autocommit;

Disable Auto Commit (Batch Jobs / ETL)
set automcommit =0

START TRANSACTION;
UPDATE wallets SET balance = balance - 100 WHERE user_id = 1;
-- No COMMIT yet
Close Workbench without COMMIT -> changes are lost

Without TCL (Dangerous)
UPDATE wallets SET balance = balance - 500 WHERE user_id = 1;
-- App crashes here
UPDATE wallets SET balance = balance + 500 WHERE user_id = 2;

With TCL (Safe kadaa)
START TRANSACTION;
UPDATE wallets SET balance = balance - 500 WHERE user_id = 1;
UPDATE wallets SET balance = balance + 500 WHERE user_id = 2;

COMMIT;
ROLLBACK;

-> DCL controls who can access and modify data. In production, we follow least privilege access to avoid security risks
Inka -> TCL ensures multiple database operations either fully succeed or fully fail, which is critical for payments and transactional systems
TCL ensures multiple dependent SQL operations execute as a single unit using START TRANSACTION, COMMIT, and ROLLBACK
-> this is critical in payment, booking, and inventory systems to maintain data consistency

Saree oka Mini Wallet System build chedhaama
Build a simple wallet system that supports:
- Wallet creation
- Balance check
- Safe money transfer
- Transaction history
- Failure handling using TCL

Step 1: Database & Tables (Schema Design)
CREATE DATABASE wallet_db;
USE wallet_db;

CREATE TABLE wallets (
    wallet_id INT PRIMARY KEY AUTO_INCREMENT,
    user_name VARCHAR(50) NOT NULL,
    balance INT NOT NULL DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE wallet_transactions (
    txn_id INT PRIMARY KEY AUTO_INCREMENT,
    from_wallet INT,
    to_wallet INT,
    amount INT NOT NULL,
    status VARCHAR(20),   -- SUCCESS / FAILED
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- wallets -> stores current balances
-- wallet_transactions -> audit log (never delete in real life)

Step 2: Insert Sample Users (Test Data idi anthee)
INSERT INTO wallets (user_name, balance) VALUES
('Sumanth', 5000),
('Mahesh', 3000),
('Rahul', 1000);
SELECT * FROM wallets;

Step 3: Check Balance (Read Operation)
SELECT wallet_id, user_name, balance
FROM wallets
WHERE user_name = 'Arjun';

Step 4: Safe Money Transfer (Core TCL Logic)
Business rule:
-> Transfer ₹X from Wallet A to Wallet B only if Wallet A has enough balance
-> If any step fails -> rollback everything

START TRANSACTION;

-- Step 1: Check sufficient balance (simulate in logic)
SELECT balance FROM wallets WHERE wallet_id = 1;  -- Arjun

-- Step 2: Deduct from sender
UPDATE wallets
SET balance = balance - 1000
WHERE wallet_id = 1 AND balance >= 1000;

-- Step 3: Add to receiver
UPDATE wallets
SET balance = balance + 1000
WHERE wallet_id = 2;

-- Step 4: Log transaction
INSERT INTO wallet_transactions (from_wallet, to_wallet, amount, status)
VALUES (1, 2, 1000, 'SUCCESS');

-- Step 5: Commit
COMMIT;

Step 5: SPARK you can Handle failure with ROLLBACK 
Scenario chudu: Sender doesn’t have enough balance/any error happenn aynappudu
START TRANSACTION;

-- Try to transfer 10000 (Arjun has only 5000)
UPDATE wallets
SET balance = balance - 10000
WHERE wallet_id = 1 AND balance >= 10000;

-- This update will affect 0 rows

-- Detect failure manually (logic in app)
ROLLBACK;

INSERT INTO wallet_transactions (from_wallet, to_wallet, amount, status)
VALUES (1, 2, 10000, 'FAILED');
-> No balance is changed
-> Failure is logged
This is exactly how real payment failures are handled

-- Total money transferred successfully elaano chudu
SELECT SUM(amount) AS total_transferred
FROM wallet_transactions
WHERE status = 'SUCCESS';

-- Top senderki query
SELECT from_wallet, SUM(amount) AS total_sent
FROM wallet_transactions
WHERE status = 'SUCCESS'
GROUP BY from_wallet
ORDER BY total_sent DESC
LIMIT 1;
