ğ‘´ğ’šğ‘ºğ‘¸ğ‘³ ğ‘¹ğ’†ğ’‡ğ’†ğ’“ğ’†ğ’ğ’•ğ’Šğ’‚ğ’ ğ‘°ğ’ğ’•ğ’†ğ’ˆğ’“ğ’Šğ’•ğ’š (ğ‘¹ğ‘°)

-> Every reference between tables must be valid and consistent
If a table says "this booking belongs to user_id = 10", then: User with user_id = 10 must exist in the users table
Ex Chudu: If a row in Table B refers to a row in Table A, that row in Table A must exist

ğ‘ğğšğ¥-ğ‹ğ¢ğŸğ ğ„ğ±ğšğ¦ğ©ğ¥ğ:
- You have a Users table
- You have an Orders table
- Every order must belong to a real user
If an order says user_id = 10, then user with id = 10 must exist

CREATE TABLE users (
  user_id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(50) NOT NULL
);

Setup Chedham (Users <-> Bookings <-> Properties)
CREATE TABLE properties (
  property_id VARCHAR(50) PRIMARY KEY,
  locality VARCHAR(100) NOT NULL
);

CREATE TABLE bookings (
  booking_id INT AUTO_INCREMENT PRIMARY KEY,
  user_id INT NOT NULL,
  property_id VARCHAR(50),
  booked_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(user_id)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  FOREIGN KEY (property_id) REFERENCES properties(property_id)
    ON DELETE SET NULL
);
-- This schema enforces referential integrity
Rule 1: Insert Rule (No Orphans on INSERT)
INSERT INTO bookings (user_id, property_id) VALUES (999, 'P101');
-- Fails because user_id = 999 does not exist in users
-> Prevents bookings for non-existing users

Rule 2 chuudu: Update Rule (Safe Updates)
UPDATE users SET user_id = 200 WHERE user_id = 20;
ON UPDATE CASCADE
-- All related bookings automatically update to user_id = 200
-> Keeps relationships consistent during migrations

Rule 3: Delete Rule (Controlled Deletes)
DELETE FROM users WHERE user_id = 10;
Depending on FK rule:
- CASCADE -> deletes all bookings of user 10
- SET NULL -> sets user_id in bookings to NULL
- RESTRICT -> blocks deletion if bookings exist
-- Prevents accidental data loss

Parent -> Child Tables
CREATE TABLE users (
  user_id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(50)
);

CREATE TABLE orders (
  order_id INT AUTO_INCREMENT PRIMARY KEY,
  user_id INT,
  FOREIGN KEY (user_id) REFERENCES users(user_id)
    -- We will change the actions here to see behavior
);

Delete Actions
- ğğ ğƒğ„ğ‹ğ„ğ“ğ„ ğ‘ğ„ğ’ğ“ğ‘ğˆğ‚ğ“ / ğğ ğ€ğ‚ğ“ğˆğğ
- ğğ ğƒğ„ğ‹ğ„ğ“ğ„ ğ‚ğ€ğ’ğ‚ğ€ğƒğ„
- ğğ ğƒğ„ğ‹ğ„ğ“ğ„ ğ’ğ„ğ“ ğğ”ğ‹ğ‹

Update Actions
- ğ—¢ğ—¡ ğ—¨ğ—£ğ——ğ—”ğ—§ğ—˜ ğ—¥ğ—˜ğ—¦ğ—§ğ—¥ğ—œğ—–ğ—§ / ğ—¡ğ—¢ ğ—”ğ—–ğ—§ğ—œğ—¢ğ—¡
- ğ—¢ğ—¡ ğ—¨ğ—£ğ——ğ—”ğ—§ğ—˜ ğ—–ğ—”ğ—¦ğ—–ğ—”ğ——ğ—˜
- ğ—¢ğ—¡ ğ—¨ğ—£ğ——ğ—”ğ—§ğ—˜ ğ—¦ğ—˜ğ—§ ğ—¡ğ—¨ğ—Ÿğ—Ÿ
-> SET DEFAULT exists in SQL standard but is not reliable in MySQL -> don't use

SPARK: If the parent row disappears or changes, should the child data still exist?
 If ques is this..                                   Choose This              
 Child data is meaningless without parent       | CASCADE              
 Child data is important history                | SET NULL             
 Parent should never be deleted if child exists | RESTRICT / NO ACTION

ğŸ. ğğ ğƒğ„ğ‹ğ„ğ“ğ„ ğ‚ğ€ğ’ğ‚ğ€ğƒğ„
- Deletes all child rows automatically when parent is deleted
FOREIGN KEY (user_id) REFERENCES users(user_id)
ON DELETE CASCADE;
DELETE FROM users WHERE user_id = 10;
-- All orders of user 10 are deleted

ğŸ®. ğ—¢ğ—¡ ğ—¨ğ—£ğ——ğ—”ğ—§ğ—˜ ğ—–ğ—”ğ—¦ğ—–ğ—”ğ——ğ—˜
- Updates child FK automatically when parent PK is updated
FOREIGN KEY (user_id) REFERENCES users(user_id)
ON UPDATE CASCADE;
UPDATE users SET user_id = 200 WHERE user_id = 20;
-- All related orders.user_id become 200

ğŸ¯. ğ—¢ğ—¡ ğ——ğ—˜ğ—Ÿğ—˜ğ—§ğ—˜ ğ—¦ğ—˜ğ—§ ğ—¡ğ—¨ğ—Ÿğ—Ÿ
Sets child FK to NULL when parent is deleted
FOREIGN KEY (user_id) REFERENCES users(user_id)
ON DELETE SET NULL;
DELETE FROM users WHERE user_id = 10;
-- Orders remain, but orders.user_id = NULL

ğŸ°. ğ—¢ğ—¡ ğ—¨ğ—£ğ——ğ—”ğ—§ğ—˜ ğ—¦ğ—˜ğ—§ ğ—¡ğ—¨ğ—Ÿğ—Ÿ
-- Sets child FK to NULL when parent PK is updated
FOREIGN KEY (user_id) REFERENCES users(user_id)
ON UPDATE SET NULL;
UPDATE users SET user_id = 200 WHERE user_id = 20;
-- orders.user_id becomes NULL

ğŸ±. ğ—¢ğ—¡ ğ——ğ—˜ğ—Ÿğ—˜ğ—§ğ—˜ ğ—¥ğ—˜ğ—¦ğ—§ğ—¥ğ—œğ—–ğ—§
-- Blocks deleting parent if child rows exist
FOREIGN KEY (user_id) REFERENCES users(user_id)
ON DELETE RESTRICT;
DELETE FROM users WHERE user_id = 10;
-- Error if orders exist

ğŸ”. ğğ ğ”ğğƒğ€ğ“ğ„ ğ‘ğ„ğ’ğ“ğ‘ğˆğ‚ğ“
-- Blocks updating parent PK if child rows exist
FOREIGN KEY (user_id) REFERENCES users(user_id)
ON UPDATE RESTRICT;
UPDATE users SET user_id = 200 WHERE user_id = 20;
-- Error if orders exist

ğŸ•. ğğ ğƒğ„ğ‹ğ„ğ“ğ„ ğğ ğ€ğ‚ğ“ğˆğğ
-- Same as RESTRICT in MySQL (blocks delete)
FOREIGN KEY (user_id) REFERENCES users(user_id)
ON DELETE NO ACTION;
-- Used as same as RESTRICT

ğŸ´. ğ—¢ğ—¡ ğ—¨ğ—£ğ——ğ—”ğ—§ğ—˜ ğ—¡ğ—¢ ğ—”ğ—–ğ—§ğ—œğ—¢ğ—¡
-- Same as RESTRICT on update
FOREIGN KEY (user_id) REFERENCES users(user_id)
ON UPDATE NO ACTION;

ğ—–ğ—”ğ—¦ğ—–ğ—”ğ——ğ—˜ ğ—‰ğ—‹ğ—ˆğ—‰ğ–ºğ—€ğ–ºğ—ğ–¾ğ—Œ ğ–½ğ–¾ğ—…ğ–¾ğ—ğ–¾/ğ—ğ—‰ğ–½ğ–ºğ—ğ–¾ ğ—ğ—ˆ ğ–¼ğ—ğ—‚ğ—…ğ–½ğ—‹ğ–¾ğ—‡ (ğ—‹ğ—‚ğ—Œğ—„ğ—’ ğ–¿ğ—ˆğ—‹ ğ—ğ—‚ğ—Œğ—ğ—ˆğ—‹ğ—’)
ğ—¦ğ—˜ğ—§ ğ—¡ğ—¨ğ—Ÿğ—Ÿ: preserves child records, removes relationship
ğ—¥ğ—˜ğ—¦ğ—§ğ—¥ğ—œğ—–ğ—§/ğ—¡ğ—¢ ğ—”ğ—–ğ—§ğ—œğ—¢ğ—¡: blocks parent delete/update if children exist (safest)
Best practice: ğ‘ˆğ‘ ğ‘’ ğ‘…ğ¸ğ‘†ğ‘‡ğ‘…ğ¼ğ¶ğ‘‡ ğ‘“ğ‘œğ‘Ÿ ğ‘“ğ‘–ğ‘›ğ‘ğ‘›ğ‘ğ‘–ğ‘ğ‘™/ğ‘ğ‘¢ğ‘‘ğ‘–ğ‘¡ ğ‘‘ğ‘ğ‘¡ğ‘; ğ¶ğ´ğ‘†ğ¶ğ´ğ·ğ¸ ğ‘œğ‘›ğ‘™ğ‘¦ ğ‘“ğ‘œğ‘Ÿ ğ‘‘ğ‘–ğ‘ ğ‘ğ‘œğ‘ ğ‘ğ‘ğ‘™ğ‘’ ğ‘â„ğ‘–ğ‘™ğ‘‘ ğ‘‘ğ‘ğ‘¡ğ‘
