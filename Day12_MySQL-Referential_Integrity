MySQL Referential Integrity (RI)
-> Every reference between tables must be valid and consistent
If a table says "this booking belongs to user_id = 10", then: User with user_id = 10 must exist in the users table
Ex Chudu: If a row in Table B refers to a row in Table A, that row in Table A must exist

Real-Life Example:
- You have a Users table
- You have an Orders table
- Every order must belong to a real user
If an order says user_id = 10, then user with id = 10 must exist

CREATE TABLE users (
  user_id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(50) NOT NULL
);

Setup Chedham (Users <-> Bookings <-> Properties)
CREATE TABLE properties (
  property_id VARCHAR(50) PRIMARY KEY,
  locality VARCHAR(100) NOT NULL
);

CREATE TABLE bookings (
  booking_id INT AUTO_INCREMENT PRIMARY KEY,
  user_id INT NOT NULL,
  property_id VARCHAR(50),
  booked_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(user_id)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  FOREIGN KEY (property_id) REFERENCES properties(property_id)
    ON DELETE SET NULL
);
-- This schema enforces referential integrity
Rule 1: Insert Rule (No Orphans on INSERT)
INSERT INTO bookings (user_id, property_id) VALUES (999, 'P101');
-- Fails because user_id = 999 does not exist in users
-> Prevents bookings for non-existing users

Rule 2 chuudu: Update Rule (Safe Updates)
UPDATE users SET user_id = 200 WHERE user_id = 20;
ON UPDATE CASCADE
-- All related bookings automatically update to user_id = 200
-> Keeps relationships consistent during migrations

Rule 3: Delete Rule (Controlled Deletes)
DELETE FROM users WHERE user_id = 10;
Depending on FK rule:
- CASCADE -> deletes all bookings of user 10
- SET NULL -> sets user_id in bookings to NULL
- RESTRICT -> blocks deletion if bookings exist
-- Prevents accidental data loss

Parent -> Child Tables
CREATE TABLE users (
  user_id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(50)
);

CREATE TABLE orders (
  order_id INT AUTO_INCREMENT PRIMARY KEY,
  user_id INT,
  FOREIGN KEY (user_id) REFERENCES users(user_id)
    -- We will change the actions here to see behavior
);

Delete Actions
- ON DELETE RESTRICT / NO ACTION
- ON DELETE CASCADE
- ON DELETE SET NULL

Update Actions
- ON UPDATE RESTRICT / NO ACTION
- ON UPDATE CASCADE
- ON UPDATE SET NULL
-> SET DEFAULT exists in SQL standard but is not reliable in MySQL -> don't use

SPARK: If the parent row disappears or changes, should the child data still exist?
 Your Answer                                     Choose This              
 Child data is meaningless without parent       | CASCADE              
 Child data is important history                | SET NULL             
 Parent should never be deleted if child exists | RESTRICT / NO ACTION

1. ON DELETE CASCADE
- Deletes all child rows automatically when parent is deleted
FOREIGN KEY (user_id) REFERENCES users(user_id)
ON DELETE CASCADE;
DELETE FROM users WHERE user_id = 10;
-- All orders of user 10 are deleted

2. ON UPDATE CASCADE
- Updates child FK automatically when parent PK is updated
FOREIGN KEY (user_id) REFERENCES users(user_id)
ON UPDATE CASCADE;
UPDATE users SET user_id = 200 WHERE user_id = 20;
-- All related orders.user_id become 200

3. ON DELETE SET NULL
Sets child FK to NULL when parent is deleted
FOREIGN KEY (user_id) REFERENCES users(user_id)
ON DELETE SET NULL;
DELETE FROM users WHERE user_id = 10;
-- Orders remain, but orders.user_id = NULL

4. ON UPDATE SET NULL
-- Sets child FK to NULL when parent PK is updated
FOREIGN KEY (user_id) REFERENCES users(user_id)
ON UPDATE SET NULL;
UPDATE users SET user_id = 200 WHERE user_id = 20;
-- orders.user_id becomes NULL

5. ON DELETE RESTRICT
-- Blocks deleting parent if child rows exist
FOREIGN KEY (user_id) REFERENCES users(user_id)
ON DELETE RESTRICT;
DELETE FROM users WHERE user_id = 10;
-- Error if orders exist

6. ON UPDATE RESTRICT
-- Blocks updating parent PK if child rows exist
FOREIGN KEY (user_id) REFERENCES users(user_id)
ON UPDATE RESTRICT;
UPDATE users SET user_id = 200 WHERE user_id = 20;
-- Error if orders exist

7. ON DELETE NO ACTION
-- Same as RESTRICT in MySQL (blocks delete)
FOREIGN KEY (user_id) REFERENCES users(user_id)
ON DELETE NO ACTION;
-- Used as same as RESTRICT

8. ON UPDATE NO ACTION
-- Same as RESTRICT on update
FOREIGN KEY (user_id) REFERENCES users(user_id)
ON UPDATE NO ACTION;

CASCADE: propagates delete/update to children (risky for history)
SET NULL: preserves child records, removes relationship
RESTRICT/NO ACTION: blocks parent delete/update if children exist (safest)
Best practice: Use RESTRICT for financial/audit data; CASCADE only for disposable child data
