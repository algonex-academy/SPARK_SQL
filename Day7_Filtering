MySQL Filtering (E-C RIM LPN SJH idi shortcut SPARK)

1. Equality - Login, profile fetch, order by ID
(WHERE column = value) - WHERE user_id = 101

2. Comparison   - High value orders, salary filters inkaa many
(WHERE column > value
WHERE column <= value)

3 Range (BETWEEN / Date Range) - Monthly/Weekly Reports, analytics, dashboards chuskochu
(WHERE column BETWEEN x AND y)
WHERE date_col >= '2025-02-01' AND date_col < '2025-02-02'

4. Multi Value filter (IN/NOT IN - You can select ultiple values at a time)
(WHERE status IN ('PAID', 'PENDING')
- Multi logical (AND/OR/NOT)
WHERE status = 'PAID' AND amount > 1000

5. LIKE/REGEXP 
LIKE is mainly used for simple pattern matching using wildcard which are faster
Wildcards:
% -> any number of characters
_ -> exactly one character

-- Starts with
SELECT * FROM users WHERE name LIKE 'Sai%';
-- Ends with
SELECT * FROM users WHERE email LIKE '%@gmail.com';
-- Contains
SELECT * FROM users WHERE name LIKE '%nath%';
-- One character match
SELECT * FROM users WHERE code LIKE 'A_3';

REGEXP is advanced pattern matching using Regular Expressions (regex - (start, end, length, character sets))

-- Must start with letters and end with @gmail.com
SELECT * FROM users
WHERE email REGEXP '^[a-z]+@gmail\\.com$';

 Pattern     meaning  
^          |  start of string
$          | for end ok
 [abc]    | a or b or c 
 [0-9]    | any digit   
 [A-Za-z] | any letter  
+         |     one or more
*         | zero or more
?         |  zero or one
{m,n}     |  between m and n times

-- 10-digit phone number
SELECT * FROM users
WHERE phone REGEXP '^[0-9]{10}$';

-- Names with 3 to 5 letters
SELECT * FROM users
WHERE name REGEXP '^[A-Za-z]{3,5}$';

-- Phone numbers starting with 9 or 8
SELECT * FROM users
WHERE phone REGEXP '^[89][0-9]{9}$';
-- Password strength Check
SELECT *
FROM users
WHERE password REGEXP '(?=.*[A-Z])(?=.*[0-9]).{8,}';

6- Partial NULL -- Incomplete profiles, data quality checks kosam
WHERE phone IS NULL
WHERE phone IS NOT NULL
- Nested (subquery) -- Filter based on another table
WHERE user_id IN (SELECT user_id FROM orders)

- Subquery EXISTS - Active users, users with/without orders
WHERE EXISTS (SELECT 1 FROM orders o WHERE o.user_id = u.user_id)

- JOIN filter - Filter early for performance chudadam kosam
JOIN orders o ON u.user_id = o.user_id AND o.amount > 1000

Aggregation Filter (HAVING - Post WHERE ayyaka)
- HAVING -- KPIs, reports, top customers
HAVING COUNT(*) > 5

1. Basic WHERE Filter
SELECT * FROM table_name
WHERE condition;

Example: 
SELECT * 
FROM Spark 
WHERE status = 'PAID';
-- Fetches only paid Spark from the users table

SELECT * -> get all columns
FROM users -> from users table
WHERE status = 'ACTIVE' -> filter rows where status is ACTIVE

=   !=   <>   >   <   >=   <=
SELECT * FROM orders WHERE amount > 1000;
SELECT * FROM users WHERE status != 'DELETED';

2. Logical Operators (AND OR   NOT)
SELECT * 
FROM orders 
WHERE status = 'PAID' AND amount > 1000; -- Fetches only paid orders above ₹1000
/* Both conditions must be true, if either fails -> row is excluded */

SELECT * FROM users
WHERE status = 'ACTIVE' AND country = 'India';

SELECT * FROM users
WHERE role = 'ADMIN' OR role = 'MANAGER';

SELECT * FROM users
WHERE NOT status = 'BLOCKED';

Multi-Value Filters (IN/NOT IN)
SELECT * 
FROM users 
WHERE role IN ('ADMIN', 'MANAGER');
/* IN (...) means "any of these values', Cleaner than role='ADMIN' OR role='MANAGER'

SELECT * FROM users
WHERE role NOT IN ('INTERN', 'TEMP');

BETWEEN / NOT BETWEEN (Range Filters)
SELECT * FROM orders
WHERE amount BETWEEN 500 AND 5000;
-- Index-friendly date range (preferred):
SELECT *
FROM orders
WHERE created_at >= '2025-01-01'
  AND created_at <  '2025-02-01';

LIKE / NOT LIKE (Pattern Matching)
SELECT * FROM users WHERE name LIKE 'Sai%';     -- starts with
SELECT * FROM users WHERE email LIKE '%@gmail.com'; -- ends with
SELECT * FROM users WHERE name LIKE '%nath%';   -- contains

Range Filter (Date / Amount)
SELECT * 
FROM orders 
WHERE created_at >= '2025-02-01'
  AND created_at <  '2025-02-02'; -- Fetches all orders created on 1st Feb 2025

/*    >= '2025-02-01' -> from start of day
< '2025-02-02' -> before next day starts
This avoids time bugs and uses indexes efficiently */

Pattern Search (LIKE)
SELECT * 
FROM users 
WHERE name LIKE 'Sai%'; -- Fetches users whose name starts with “Sai”
(e.g., Sai, Sainath, Saikiran)
-- 'Sai%' -> % means "anything after" Starts with Sai

NULL Check
SELECT * 
FROM users 
WHERE phone IS NULL; -- Fetches users who did not provide phone number
-- IS NULL checks missing values
-- phone = NULL is wrong in SQL

Relational Filter (EXISTS)- Simplega untundhi
SELECT *
FROM users u
WHERE EXISTS (
  SELECT 1 
  FROM orders o 
  WHERE o.user_id = u.user_id
); -- Fetches users who have placed at least one order

/* Inner query checks if any order exists for that user
If yes -> include user
SELECT 1 is just a placeholder (we only care if row exists) */

Anti-Filter (NOT EXISTS kudaa chudu)
SELECT *
FROM users u
WHERE NOT EXISTS (
  SELECT 1 
  FROM orders o 
  WHERE o.user_id = u.user_id
); -- Fetches users who never placed any order
