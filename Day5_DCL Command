4. DCL (Data Control Language) (GRANT, REVOKE)
- Who can access what? Who can do what?
-> This is database security + access control privileges in Algonex Company Server/DB for controlled access

Manam Companies lo ela vaduthaam:
- Giving read-only access to analysts
- giving write access to backend services for implementation 
- Blocking dangerous permissions in prod
- Creating separate roles for Dev, QA, Prod

1. GRANT â€” Giving Controlled Access/privileges for authorized users
Really where you'll have:
- Backend service (needs read/write)
- Analyst (read-only)
- Intern (very limited) all access based on privilege in company kadaa
privileges (SELECT(read), UPDATE(read-write), DELETE(read-write) - CRUD Operations 

GRANT privileges
ON database.table
TO 'user'@'host';

Konni example chuudu mem ela Algonexlo isthamo: 
1.give read only(SELECT) access to analyst/Intern
GRANT SELECT
ON ecommerce_db.*
TO 'analyst'@'%';

2.Give full CRUD(CRAETE, READ, UPDATE, DELETE) to backend service
GRANT SELECT, INSERT, UPDATE, DELETE
ON ecommerce_db.*
TO 'backend_service'@'%';

3. Give permission to run procedures
GRANT EXECUTE
ON PROCEDURE ecommerce_db.process_order
TO 'api_user'@'%';

Note: - never give ALL PRIVILEGES in production
-> Grant only what is required (principle of least Privilege -> entha takkuvithe antha)
-> Use separate 'users' for:
- app
- admin
- analytics
- Intern

-> Pyna meeku ardham kaaledhani naakardhamaindi, so idi chuudu:
STEP-1: Create User
CREATE USER 'dev_user'@'localhost' IDENTIFIED BY 'Dev@123';
Step-2: Grant the privileges for created user
GRANT SELECT, INSERT, UPDATE
ON mydb.*
TO 'dev_user'@'localhost';
-> Can connect only from their own laptop

2.  Backend application server access
CREATE USER 'backend_app'@'192.168.1.50' IDENTIFIED BY 'App@123';
GRANT SELECT, INSERT, UPDATE, DELETE
ON ecommerce_db.*
TO 'backend_app'@'192.168.1.50';
-> Only your app server can use this DB user

3. Cloud / API service (cloud allowed access from anywhere)
CREATE USER 'api_user'@'%' IDENTIFIED BY 'Api@123';
GRANT SELECT, INSERT, UPDATE
ON ecommerce_db.*
TO 'api_user'@'%';


2. REVOKE - Removing Access Safely when you understand data misuse/Project work is finished
Real scenarioslo ekkada: 
- Intern leaves
- Contractor access expired
- User misused permissions
- Security breach response

REVOKE privileges
ON database.table
FROM 'user'@'host';

Example:
REVOKE INSERT, UPDATE, DELETE
ON ecommerce_db.*
FROM 'intern'@'%';

SPARK Tip: Always revoke first, then delete users,this avoids accidental downtime

SPARK: CREATE USER
Evaristharu access:
- DB Admins
- DevOps pipelines
- Cloud provisioning scripts

CREATE USER 'username'@'host' IDENTIFIED BY 'password';

Ex: CREATE USER 'report_user'@'%' IDENTIFIED BY 'Strong@123';
-> Never hardcode passwords in SQL scripts in production/Project flow
-> Use secrets manager /environment variables

3. DROP USER - Access Cleanup(Once the project is done)
DROP USER 'report_user'@'%';

4. SHOW GRANTS - Audit(log files) & Debugging kosam
- Security audits
- Debug permission errors
- Compliance checks

SHOW GRANTS FOR 'backend_service'@'%';

Algonexloo memelaa access istham ee Privileges:
 Role                Privileges                   
 Backend AppDev | SELECT, INSERT, UPDATE       
 Analyst        | SELECT                       
 Admin       | ALL PRIVILEGES (rarely use chestham cz no many admins ) 
 Intern      | SELECT on few tables         
 ETL Jobs    | SELECT, INSERT               
-> This separation/access avoids accidental data loss right

Mistake 1: Granting but user doesn't exist
GRANT SELECT ON mydb.* TO 'user1'@'%'; -- Error happens if user is not created first

Ilaa fix chey: 
CREATE USER 'user1'@'%' IDENTIFIED BY 'Pass@123';
GRANT SELECT ON mydb.* TO 'user1'@'%';

Mistake 2: Created user with localhost, trying from outside
CREATE USER 'app_user'@'localhost' ...
Then connecting from server IP -> Access denied

CREATE USER 'app_user'@'%' ...

Practise kosam: 
CREATE USER 'test_user'@'localhost' IDENTIFIED BY 'Test@123';
GRANT SELECT ON test.* TO 'test_user'@'localhost';
SHOW GRANTS FOR 'test_user'@'localhost';

 Host Value                    Why               Real Use          
 'localhost'         | Only from same machine | Local dev         
   '%'               | From anywhere          | Cloud apps        
 '192.168.1.10'      | From specific IP adress | App server        
 'app.company.com'   | From specific domain   | Production server 

DCL Commands in MySQL Workbench (Hands-on, Industry pointlo chudham)
These are steps:
- create users
- give permissions
-test access
-revoke permissions
- manage real-world roles (Admin / app/ analyst)

-> Open MySQL Workbench
-> Connect to Local instance MySQL80 using root password
        -> Root/admin access is required to create users and grant permissions right

CREATE DATABASE company_db;
USE company_db;

CREATE TABLE employees (
    emp_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    role VARCHAR(50),
    salary INT
);

INSERT INTO employees (name, role, salary) VALUES
('Sumanth', 'Developer', 60000),
('Prathibha', 'Analyst', 50000),
('Pasala Ganesh', 'HR', 45000);

2nd Step: Create Users (antee industry Roles) -> Ivee imp steps DCL ki
1. Create an Analyst (Read-only)
CREATE USER 'analyst_user'@'localhost' IDENTIFIED BY 'Analyst@123';

2. Create a Backend App User (Read & Write)
CREATE USER 'app_user'@'localhost' IDENTIFIED BY 'App@123';
3. Create an Intern (Limited)
CREATE USER 'intern_user'@'localhost' IDENTIFIED BY 'Intern@123';

3rd Step: Grant Permissions (Real Algonex Company-Based Pattern)
1. Analyst -> Only SELECT
GRANT SELECT
ON company_db.*
TO 'analyst_user'@'localhost';
2. App User -> SELECT, INSERT, UPDATE
GRANT SELECT, INSERT, UPDATE
ON company_db.*
TO 'app_user'@'localhost';
3. Intern -> SELECT only on employees table
GRANT SELECT
ON company_db.employees
TO 'intern_user'@'localhost';

Apply Privileges immediately (Important Step)
FLUSH PRIVILEGES; --  This forces MySQL to apply permission changes immediately late avvkundaa

4th Step: Verify Permissions/acces (Audit / Debug cehskovali)
SHOW GRANTS FOR 'analyst_user'@'localhost';
SHOW GRANTS FOR 'app_user'@'localhost';
SHOW GRANTS FOR 'intern_user'@'localhost';
-- Akkada chuduchu which user can do what anii

5th Step: Test Access in MySQL Workbench (Mem generally chesthuntam)
tep A: Create New Connection in Workbench
In MySQL Workbench home screen
Click + next to MySQL Connections
Connection Name: Analyst Connection
Username: analyst_user
Password: Analyst@123
Test Connection -> OK

Step B: Try Queries as Analyst
USE company_db;
SELECT * FROM employees;   -- Work avuthundi kadaa

INSERT INTO employees (name, role, salary)
VALUES ('Test', 'Tester', 30000); -- This will fail endukante Permission denied

6th Step: Revoke Permissions (When User Role Changes)
Real Scenario entante: Intern should not access employees table anymore
REVOKE SELECT
ON company_db.employees
FROM 'intern_user'@'localhost';

SHOW GRANTS FOR 'intern_user'@'localhost'; -- Now intern_user cannot read employees data

Drop User (When Employee Leaves Company)
DROP USER 'intern_user'@'localhost'; --Intern leaves, Contract ends, Security incident

-- In MySQL Workbench, DCL is used to create users and control access using GRANT and REVOKE. 
In production/Projects anochu, we follow least-privilege access where app users get only required permissions and analysts get read-only access

