5. TCL (Transaction Control Language)- Safety system for data
How companies/ATM's ensure money, inventory, bookings never go wrong
-> It ensures that multiple related changes happen together or don’t happen at all
-> Either the full business operation succeeds, or everything is undone

TCL is used whenever:
- Money is transferred
- Orders are placed
- Seats are booked
- Inventory is updated
- Wallet balances change
-> If one step fails and others succeed -> data becomes wrong, TCL prevents this

TCL ensures ACID properties:
- Atomicity -> All or Nothing
Either all steps of a transaction happen, or none happen (No half-success allowed)

Atomicity lekpothee(Wrong)
- Money deducted
-App crashes
-Money not added -> Data becomes wrong
-- With TCL (Atomicity elaa work avuthubdi chudandii)
START TRANSACTION;

UPDATE wallets SET balance = balance - 1000 WHERE wallet_id = 1;
UPDATE wallets SET balance = balance + 1000 WHERE wallet_id = 2;

COMMIT;   -- both succeed
-- or
ROLLBACK; -- if any step fails
-- Either both updates happen or both are undone

- consistency-> Rules must Always be true
-> After a transaction, database rules and business rules are not broken
-> data should move from one valid state to another valid state
Rule: Wallet balance should never go below 0
UPDATE wallets SET balance = -500 WHERE wallet_id = 1; -- Without Consistency, business rule broken

With Constraints + TCL (Consistency)
START TRANSACTION;

UPDATE wallets
SET balance = balance - 1000
WHERE wallet_id = 1 AND balance >= 1000;

-- If 0 rows affected → not enough balance → rollback
ROLLBACK;

Company Examples wihch explains Consistency Rules:
- Balance ≥ 0
- Foreign key must exist
- Status must be valid
- Inventory can't go negative

- Isolation -> My Transaction is Private ani antee Corona ward annu kadaa antee bayata pranpanchamtho sambandhamledhu
-> Multiple users using DB at same time don't disturb each others transactions
->One user should not see half-done work of another user
Example: Two people try to spend Harshath's wallet at the same time soo avuthundaa ala?
Without Isolation emavuthundi: Both see same balance and spend -> money goes negative cz iddaru karchupedthaaru kadaa

With Isolation (Row Lock chesthaam)
START TRANSACTION;

SELECT balance
FROM wallets
WHERE wallet_id = 1
FOR UPDATE;   -- locks the row

UPDATE wallets SET balance = balance - 500 WHERE wallet_id = 1;

COMMIT;
Other transactions must wait until this one finishes.
Used in:
- Banking
- Booking seats
- Inventory deduction

- DURABILITY:  Once Saved, It stays Saved
Once COMMIT is done, data will not be lost even if:
- Server crashes
- Power goes off
- App restarts

User sees "Payment Successful' -> even if DB server crashes after that -> money transfer must remain saved
Algonex/edina company Support for Durability how?:
- Write-ahead logs
- Disk persistence
- Backups
- Replication

 ACID Property      ANtee enti                   TCL Role                              |
 Atomicity   | All or nothing           | START TRANSACTION + COMMIT/ROLLBACK 
Consistency | Rules not broken         | Constraints + validation + ROLLBACK   |
 Isolation   | Transactions don’t clash | Locks, isolation levels               |
 Durability  | Saved means saved        | COMMIT + disk logs                    |
Spark Tips to remember:
-> All or nothing
-> Correct state
-> Isolated from others
-> Data never lost

ACID properties ensure transactions are reliable in real systems
Atomicity ensures all-or-nothing execution, 
Consistency ensures business rules are maintained,
Isolation prevents concurrent transactions from interfering,
and Durability ensures committed data is permanently saved even after failures

CREATE DATABASE bank_db;
USE bank_db;

CREATE TABLE accounts (
    acc_id INT PRIMARY KEY,
    name VARCHAR(50),
    balance INT
);

INSERT INTO accounts VALUES
(1, 'Dithya', 5000),
(2, 'Subhash', 3000); -- Now imagine this as a bank/wallet system

COMMIT, ROLLBACK, SAVEPOINT

1. START TRANSACTION -  Begin Safe Operations
-> Now I’m starting a business process that has multiple steps, treat them as one unit

start TRANSACTION;

Used when: 
-> Multiple queries must succeed together
-> Payment + order + inventory update
(Ex: When you start payment Transaction it should complete the order commit 
completely/come to initial step and update payment details)

2. COMMIT -> Make Changes Permanent if everything is ok

COMMIT;

Where it is used:
- Payment succeeded
- Order placed
- Booking confirmed
START TRANSACTION;

UPDATE accounts SET balance = balance - 1000 WHERE acc_id = 1;  -- Arjun pays
UPDATE accounts SET balance = balance + 1000 WHERE acc_id = 2;  -- Neha receives

COMMIT;
->Both updates succeed
-> Money moves correctly
-> Changes become permanent

3. ROLLBACK — Something went wrong, Undo Everything (Safety Purpose -> Example chudham)
ROLLBACK;

When:
- payment failed
- Inventory insufficient
- any step errors/failed

Example Without TCL (Wrong Way chudandii)
UPDATE accounts SET balance = balance - 1000 WHERE acc_id = 1;
-- Server crashes here kadaa
UPDATE accounts SET balance = balance + 1000 WHERE acc_id = 2;
-- Money is deducted but not added, data is corrupted

Example With TCL (Correct Way ippudu chudu)
START TRANSACTION;
UPDATE accounts SET balance = balance - 1000 WHERE acc_id = 1;
-- Something goes wrong
ROLLBACK;
-- Since second step didn’t complete
-- ROLLBACK undoes the first step
-- Data stays safe

4. SAVEPOINT — Partial Rollback-> Undo only part of the work (Advanced use antaam)
Used in:
- Booking systems
- Multi-step workflows
- Complex order flows
Example flow chudandi:
1. Create order
2. Deduct wallet
3-Reserve inventory
If step 3 fails -> undo step 2 only

SAVEPOINT sp_name;
ROLLBACK TO sp_name;

Booking Flow CHudhaama:
START TRANSACTION;

INSERT INTO bookings (...) VALUES (...);

SAVEPOINT after_booking;

UPDATE inventory SET seats = seats - 1 WHERE flight_id = 10;

-- If inventory update fails
ROLLBACK TO after_booking;

COMMIT;

Savepoints inkoo example flow chudu:
START TRANSACTION;
UPDATE accounts SET balance = balance - 500 WHERE acc_id = 1;  -- deduct wallet
SAVEPOINT after_wallet;

-- Try another step (simulate failure)
UPDATE accounts SET balance = balance + 500 WHERE acc_id = 999;  -- invalid account
ROLLBACK TO after_wallet;
COMMIT;

-> Deduction happened
-> Second update failed
-> Roll back only to savepoint
-> Commit remaining safe steps

5. AUTOCOMMIT - Dinni hidden transaction Behavior antaam
By default: Every query is auto-committed (saved immediately)
Check: SELECT @@autocommit;
In batch jobs / ETL: SET autocommit = 0; -- Now you control manually when data is saved using COMMIT/ROLLBACK

AUTOCOMMIT = ON (Idi defaultga untundhi)

 Real Systemloo                    TCL Usage                            
 UPI / Banking     | Money transfer must be atomic        
 E-commerce        | Order + inventory + payment together 
Ticket Booking | Seat lock + payment + confirmation   
 ERP           | Multi-table updates                  
 Wallet Apps   | Debit + credit                       

ILAA CHESKOO EPPUDINAA TCL Commands vadthunnappudu:
START TRANSACTION;
-- operations
COMMIT;  -- or ROLLBACK

Saree GPay payment System Working chudhama:
START TRANSACTION;

UPDATE wallets SET balance = balance - 1000 WHERE user_id = 1;
UPDATE wallets SET balance = balance + 1000 WHERE user_id = 2;

INSERT INTO transactions(user_id, amount, status)
VALUES (1, 1000, 'SUCCESS');

COMMIT;

Ippudu edina system fail ayindi antee:
then: ROLLBACK;
-> Ilaane banks, UPI, wallets, e-commerce stay correct anamaata

Using TCL Commands in MySQL Workbench (Hands-on, Comapnylo follow ayye  Way)
Open MySQL Workbench -> connect as root, then run:
CREATE DATABASE finance_db;
USE finance_db;

CREATE TABLE wallets (
    user_id INT PRIMARY KEY,
    name VARCHAR(50),
    balance INT
);

INSERT INTO wallets VALUES
(1, 'JayaKrishna', 5000),
(2, 'DIthya', 3000)
(3, 'Niharika', 30000); -- wallet/paymnt system used in fintech & e-commerceloo

1st Step: START TRANSACTION — Begin a Safe Business Operation (Endukoo chudandi)
Used when:
- Transferring money
- Placing orders
- Booking tickets
- Updating inventory + order status together

START TRANSACTION; 

2nd Step:
UPDATE wallets
SET balance = balance - 1000
WHERE user_id = 1;

UPDATE wallets
SET balance = balance + 1000
WHERE user_id = 2;

Money is moved from JayaKrishna to DIthya
At this point:
- Data is not permanent yet
- It’s still inside the transaction

3rd step: COMMIT — Make It Permanent (Success Case idi)
COMMIT; -- Payment succeeded -> save changes permanently
SELECT * FROM wallets; -- You're zeeing updated balances right

4th Step: ROLLBACK — Undo Everything (Failure Case)
Start a new transaction:
START TRANSACTION;
-- Okasaari ivi kuda try cheyandi
UPDATE wallets SET balance = balance - 10000 WHERE user_id = 1;  -- Not enough money
UPDATE wallets SET balance = balance + 10000 WHERE user_id = 2;

-- Now instead of COMMIT:
ROLLBACK;

SELECT * FROM wallets; -- Chusthee balances will be unchanged
This is how banks & UPI apps prevent wrong transfers

5sth Step: SAVEPOINT — Partial Rollback
In a booking system:
- Create booking
= Deduct wallet
- Reserve inventory
If step 3 fails -> undo step 2 only

-- IDi overallga
START TRANSACTION;

UPDATE wallets SET balance = balance - 500 WHERE user_id = 1;

SAVEPOINT after_wallet_deduct;

-- Simulate failure or wrong update
UPDATE wallets SET balance = balance + 500 WHERE user_id = 999;  -- invalid user

ROLLBACK TO after_wallet_deduct;

COMMIT;
-- Wallet deduction is undone, but transaction is still valid

6th Step: (ANdaru students aduguthuntaaru )
AUTOCOMMIT — Hidden Behavior (Important for Fresher amigos)
Every query commits automatically default in MySQL
SELECT @@autocommit;

Disable Auto Commit (Batch Jobs / ETL)
set automcommit =0

START TRANSACTION;
UPDATE wallets SET balance = balance - 100 WHERE user_id = 1;
-- No COMMIT yet
Close Workbench without COMMIT -> changes are lost

Without TCL (Dangerous)
UPDATE wallets SET balance = balance - 500 WHERE user_id = 1;
-- App crashes here
UPDATE wallets SET balance = balance + 500 WHERE user_id = 2;

With TCL (Safe kadaa)
START TRANSACTION;
UPDATE wallets SET balance = balance - 500 WHERE user_id = 1;
UPDATE wallets SET balance = balance + 500 WHERE user_id = 2;

COMMIT;
ROLLBACK;

-> DCL controls who can access and modify data. In production, we follow least privilege access to avoid security risks
Inka -> TCL ensures multiple database operations either fully succeed or fully fail, which is critical for payments and transactional systems
TCL ensures multiple dependent SQL operations execute as a single unit using START TRANSACTION, COMMIT, and ROLLBACK
-> this is critical in payment, booking, and inventory systems to maintain data consistency

Saree oka Mini WALLET SYSTEM build chedhaama that supports:
- Wallet creation
- Balance check
- Safe money transfer
- Transaction history
- Failure handling using TCL

Step 1: Database & Tables (Schema Design)
CREATE DATABASE wallet_db;
USE wallet_db;

CREATE TABLE wallets (
    wallet_id INT PRIMARY KEY AUTO_INCREMENT,
    user_name VARCHAR(50) NOT NULL,
    balance INT NOT NULL DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE wallet_transactions (
    txn_id INT PRIMARY KEY AUTO_INCREMENT,
    from_wallet INT,
    to_wallet INT,
    amount INT NOT NULL,
    status VARCHAR(20),   -- SUCCESS / FAILED
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- wallets -> stores current balances
-- wallet_transactions -> audit log (never delete in real life)

Step 2: Insert Sample Users (Test Data idi anthee)
INSERT INTO wallets (user_name, balance) VALUES
('Sumanth', 5000),
('Mahesh', 3000),
('Rahul', 1000);
SELECT * FROM wallets;

Step 3: Check Balance (Read Operation)
SELECT wallet_id, user_name, balance
FROM wallets
WHERE user_name = 'Arjun';

Step 4: Safe Money Transfer (Core TCL Logic)
Business rule:
-> Transfer ₹X from Wallet A to Wallet B only if Wallet A has enough balance
-> If any step fails -> rollback everything

START TRANSACTION;

-- Step 1: Check sufficient balance (simulate in logic)
SELECT balance FROM wallets WHERE wallet_id = 1;  -- Arjun

-- Step 2: Deduct from sender
UPDATE wallets
SET balance = balance - 1000
WHERE wallet_id = 1 AND balance >= 1000;

-- Step 3: Add to receiver
UPDATE wallets
SET balance = balance + 1000
WHERE wallet_id = 2;

-- Step 4: Log transaction
INSERT INTO wallet_transactions (from_wallet, to_wallet, amount, status)
VALUES (1, 2, 1000, 'SUCCESS');

-- Step 5: Commit
COMMIT;

Step 5: SPARK you can Handle failure with ROLLBACK 
Scenario chudu: Sender doesn’t have enough balance/any error happenn aynappudu
START TRANSACTION;

-- Try to transfer 10000 (Arjun has only 5000)
UPDATE wallets
SET balance = balance - 10000
WHERE wallet_id = 1 AND balance >= 10000;

-- This update will affect 0 rows

-- Detect failure manually (logic in app)
ROLLBACK;

INSERT INTO wallet_transactions (from_wallet, to_wallet, amount, status)
VALUES (1, 2, 10000, 'FAILED');
-> No balance is changed
-> Failure is logged
This is exactly how real payment failures are handled

-- Total money transferred successfully elaano chudu
SELECT SUM(amount) AS total_transferred
FROM wallet_transactions
WHERE status = 'SUCCESS';

-- Top senderki query
SELECT from_wallet, SUM(amount) AS total_sent
FROM wallet_transactions
WHERE status = 'SUCCESS'
GROUP BY from_wallet
ORDER BY total_sent DESC
LIMIT 1;
